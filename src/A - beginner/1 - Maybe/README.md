# Контейнер Maybe

Контейнер Maybe — это способ представления nullable-значений так, чтобы с ними было возможно работать безопасным способом.

> В терминологии `fp-ts` Maybe — это тип данных `Option`, доступный в модуле `fp-ts/lib/Option`. Тем не менее, в дидактических целях я буду использовать именно название Maybe для этого упражнения.

По сути, Maybe — это т.н. «размеченное объединение», по-английски «discriminated union» (google it!), и определяется очень просто:

```ts
type Nothing = Readonly<{ tag: 'Nothing' }>;
type Just<A> = Readonly<{ tag: 'Just'; value: A }>;
type Maybe<A> = Nothing | Just<A>;
```

Для удобства работы также определяют пару конструкторов:

```ts
const nothing: Maybe<never> = { tag: 'Nothing' };
const just = <A>(value: A): Maybe<A> => ({ tag: 'Just', value });
```

> **Заметка про классы типов (type classes)**
> 
> В дальнейшем я буду использовать термин «класс типа» или «тайпкласс». Все конструкции, которые мы будем рассматривать в дальнейших ката, — функтор, аппликатив, монада — будут являться классами типа. Вы можете думать о них как об интерфейсах, которые определяют некое поведение. Если тип является частью тайплкасса, то это значит, что он реализует и поддерживает то поведение, которое описавыет тайпкласс. 
> 
> В языке TypeScript «чистых» тайпклассов нет, поэтому я буду описывать их при помощи интерфейсов. Я буду использовать термин «экземпляр (тайпкласса) X для (контейнера) Y», чтобы подчеркнуть, что интерфейс X не должен быть жёстко вшит в контейнер Y, а может быть определен независимо. Например, это даёт вам возможность импортировать в свою программу только ту часть тайпклассов для вашего контейнера Y, которая необходима в данный конкретный момент.

## Функтор (Functor)

О функторе для Maybe можно думать как об интерфейсе, реализующем только один метод — `fmap`:

```ts
interface Functor<A> {
  fmap: <B>(f: (a: A) => B) => (ma: Maybe<A>) => Maybe<B>;
}
```

Метод `fmap` можно рассматривать с двух сторон:
1. Как способ «применить» чистую функцию к «контейнеризированному» значению;
2. Как способ «поднять в контекст контейнера» чистую функцию.

Действительно, если немного по-другому расставить скобки в интерфейсе, мы можем получить такую сигнатуру функции `fmap`:

```ts
const fmap: <A, B>(f: (a: A) => B) => ((ma: Maybe<A>) => Maybe<B>);
```

Можно воспользоваться интерфейсом `Function1` из `fp-ts`, и получить такое определение `fmap`:

```ts
const fmap: <A, B>(f: (a: A) => B) => Function1<Maybe<A>, Maybe<B>>;
```

Функтор должен подчиняться двум алгебраическим законам:

1. Закон сохранения композиции функций: `fmap f ∘ fmap g ≅ fmap (f ∘ g)`
2. Закон сохранения идентичности: `fmap id ≅ id`

Ваша задача — определить экземпляр функтора для контейнера Maybe, написав функцию `fmap`.

## Аппликативный функтор (Applicative)

Аппликативный функтор позволяет применить функцию, поднятую в контекст, к значению в этом контексте. Об аппликативном функторе для Maybe можно думать как об интерфейсе, определяющем пару операций:

```ts
interface Applicative<A> {
  of: (a: A) => Maybe<A>;
  ap: <B>(fab: Maybe<(a: A) => B>) => (ma: Maybe<A>) => Maybe<B>;
}
```

Аппликативный функтор подчиняется 4 законам:

1. Идентичность: `ap (of id) ma ≅ ma`
2. Гомоморфизм: `ap (of ab) (of a) ≅ of (ab a)`
3. Заменяемость: `ap fab (of a) ≅ ap (\ab -> ab a) fab`
4. Композиция: `ap (ap (ap (of compose) u) v) w ≅ ap u (ap v w)`

Ваша задача — определить экземпляр аппликативного функтора для Maybe, написав функции `of` и `ap`.

## Альтернатива (Alternative)

Альтернатива позволяет вам определить пару операций: ассоциативную операцию `alt`, которая «делает выбор» из двух своих аргументов, и операцию `zero`, которая служит нейтральным (нулевым) элементом для операции `alt` как слева, так и справа. Альтернатива может быть реализована для аппликативного функтора — из-за требования ассоциативности `alt` и наличия нейтрального элемента.

Вы можете думать об альтернативе как о бинарной операции `||` в JS, только для контейнеров:

```js
const iamnull = null;
const iamnotnull = 'hello';
const fallback = 42;

const result1 = iamnull || fallback; // => 42;
const result2 = iamnotnull || fallback; // => 'hello';
```

Альтернатива должна подчиняться законам:

1. Левой идентичности: `alt zero ma ≅ ma`
2. Правой идентичности: `alt ma zero ≅ ma`
3. Ассоциативности: `alt (alt ma mb) mc ≅ alt ma (alt mb mc)`
4. Дистрибутивности: `ap (alt fab gab) ma ≅ alt (ap fab ma) (ap gab ma)`
5. Аннигиляции: `fmap zero f ≅ zero`, `ap fa zero ≅ zero`

Ваша задача — определить экземпляр альтернативы для Maybe, написав функции `zero` и `alt`.

## Монада (Monad)

Монада объединяет в себе интерфейс аппликативного функтора и интерфейс `Chain` — последовательной цепочки вычислений, использующей результат предыдущей функции для определения последовательности следующих функций.

Вы можете думать о монаде для Maybe как об интерфейсе, реализующем функции `of` и `chain`:

```ts
interface Monad<A> {
  of: (a: A) => Maybe<A>;
  chain: <B>(f: (a: A) => Maybe<B>) => (ma: Maybe(A)) => Maybe<B>;
}
```

Монада должна подчиняться трём законам:

1. Левой идентичности: `chain f (of a) ≅ f a`
2. Правой идентичности: `chain of fa ≅ fa`
3. Ассоциативности: `chain (chain afb fa) bfc ≅ chain (\a -> chain bfc (afb a)) fa`

и всем законам для аппликативного функтора.

> Важный момент: монада может определяться не только парой `of` и `chain`, но и парой `of` и `flatten`!

Функция `flatten` осуществляет «схлопывание» одного уровня контейнера:

```ts
const flatten: <A>(mma: Maybe<Maybe<A>>) => Maybe<A>;
```

Функции `chain` и `flatten` могут быть выражены друг через друга:

```ts
const chain = f => ma => flatten(fmap(f)(ma));
const flatten = mma => chain(fmap(identity))(mma);
```

Поэтому в некоторых функциональных библиотеках операция `chain` еще может носить название `flatMap`, что более точно отражает ее суть: она «поднимает» (map) вычисления вида `A => F<B>` в контекст `F`, получает промежуточный результат вида `F<F<B>>`, а потом «уплощает» один уровень, возвращая просто `F<B>`.

> Кстати, в стандарте ECMAScript 2015 для массивов определена операция `flatMap`, которая как раз и является монадической операцией `chain`.

Ваша задача — определить экземпляр монады для Maybe, написав функции `chain` и `flatten`.

# Выводы

Я надеюсь, что после прохождения этой ката вы сделаете следующие выводы:

1. Понятие «контейнер» не эквивалентно понятиям «монада»/«функтор»/«аппликатив»/etc., поскольку мы определяем экземпляры тайпклассов функтор/монада/etc. *для* контейнера, а не *модифицируем* сам контейнер.
2. В ваших программах может использоваться только часть интерфейсов контейнера, имеющего экземпляры для нескольких тайпклассов. Это позволяет вам использовать принцип наименьшего знания и ограничивать в коде типы аргументов функций только теми возможностями, которые вам нужны в конкретный момент времени. Например, при использовании `fp-ts` можно запрашивать только нужные вам экземпляры тайпклассов:

    ```ts
    // Предположим, что в `foo` вы используете только `of`.
    // Тогда вместо:
    const foo: (M: Monad<F>) => <A, B>(fa: HKT<F, A>) => HKT<F, B>;
    // можно написать:
    const foo: (M: Applicative<F>) => <A, B>(fa: HKT<F, A>) => HKT<F, B>;
    ```

    Про нотацию `HKT<F, A>` мы поговорим позже, когда дойдем до определения типов высших порядков.
3. Из-за того, что тайпклассы функтора, монады, аппликатива, альтернативы и т.д. подчиняются алгебраическим законам, их можно выражать друг через друга и переиспользовать части их интерфейсов.
